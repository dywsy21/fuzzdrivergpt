# Technical Overview

## Query strategies

A query strategy defines a way to generate prompt(s). The following table lists all strategies integrated into `fuzzdrivergpt` and you can pick one depending on what you have.
The strategies of `fuzzdrivergpt` are motivated by the findings of our recent [research](https://github.com/occia/fuzzdrivergpt/tree/main/doc/research_paper.md) on the pros and cons of various LLM-based fuzz driver generation strategies. 
In our evaluation, the iterative strategies have best performance but their potential GPT costs can be high.

|Query Strategy| API Decl| API Doc| Example Code| Iterative Fix|
| ---          | ---     | ---    | ---         | ---          |
| NAIVE        | &cross; | &cross;| &cross;     | &cross;      |
| BACTX        | &check; | &cross;| &cross;     | &cross;      |
| DOCTX        | &check; | &check;| &cross;     | &cross;      |
| UGCTX        | &check; | &cross;| &check;     | &cross;      |
| ITER-BA      | &check; | &cross;| &cross;     | &check;      |
| ITER-ALL     | &check; | &check;| &check;     | &check;      |

## Effectiveness validation

Automatically validating a fuzz driver is effective or not in scale is challengable since it requires the deep understanding of target API semantics.
In general, `fuzzdrivergpt` validates a fuzz driver by first compiling the driver code and then fuzzing it for a short time period, e.g., 1 min, with empty seed corpus.
If the fuzzing ends without finding any bug, it is a valid driver.
The intuition here is that the driver is not likely to find crash under a poor fuzzing setup.
Obviously this does not suit every case.
For advanced users who want to search more and filter hard for better driver generation, `fuzzdrivergpt` will support configurable validation criteria soon.

##  Customized Use of Generation Strategies

Here are multiple ways to generate fuzz drivers using `fuzzdrivergpt` for a given API.

### One-Round Mode: Generate-only

The following command queries a prompt generated by BACTX query strategy, and save the code returned by GPT model into the specified json.

```bash
python main.py -l c -m gpt-4-0314 -t md4c -f md_html -q BACTX -DV -o test.json
# Expected Output: test_round1.json
```

### One-Round Mode: Generate and validate

The following command queries a prompt generated by BACTX query strategy, validates the code returned by GPT model, and saves all detail into the specified json.

```bash
python main.py -l c -m gpt-4-0314 -t md4c -f md_html -q BACTX -o test.json
# Expected Output: test_round1.json
```

### One-Round Mode: Iteratively generate, validate, and fix until succeed or maximum iterations are reached

For the following command, it does:

- 1) Query a prompt generated by BACTX query strategy
- 2) Validate the code returned by GPT model
- 3) If the code passes the validation or the the maxiteration (20 in the case) is reached, stop and save all detail into the specified json
- 4) Otherwise, propose a fix prompt based on the error, then goto 2).

```bash
python main.py -l c -m gpt-4-0314 -t md4c -f md_html -q ITER-BA -MI 20 -o test.json
# Expected Output: test_round1.json
```

### Search Mode: Repeatedly do one-round mode until succeed or maximum rounds are reached

All the processes of the above commands can be repeatedly done to search for valid drivers by adding `-MR MAXROUNDS`.
For example. the following repeats the above iterative query process for at most 3 times.

```bash
python main.py -l c -m gpt-4-0314 -t md4c -f md_html -q ITER-BA -MI 20 -MR 3 -o test.json
# Expected Output: test_round1.json, test_round2.json, test_round3.json, 
```